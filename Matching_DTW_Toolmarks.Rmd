---
title: "Match toolmarks with DTW"
author: "Christophe Champod"
date: "04/01/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#Load required packages and functions
source("Packages_and_Functions.R")
```

# Load data

The function ImportToolmarksData() below will read all .txt files in a folder and prepare a dataframe with the relevant information.

```{r load_data}
ResToolMarks <- readRDS("ResToolMarks.Rds")
```

A few test using the DTW package. https://dtw.r-forge.r-project.org/
```{r}
a <- Extract_One_profile(ResToolMarks,1)$y
b <- Extract_One_profile(ResToolMarks,7)$y


## Find the best match with the canonical recursion formula
alignment <- dtw(a,b,keep=TRUE)

## Display the warping curve, i.e. the alignment curve
plot(alignment,type="threeway")

## Display distance points (as many as wanted) with offset for viewing
plot(dtw(a,b,k=TRUE), 
          type="two",off=1,match.lty=2,
          match.indices=20)

## Plot the reference profile and the warped profile with DTW alignement

a_index<-dput(as.double(alignment$index1s));
Stretch_a<-(a[c(a_index)]);

b_index<-dput(as.double(alignment$index2s));
Stretch_b<-(b[c(b_index)]);

a_df <- as.data.frame(cbind(c(1:length(Stretch_a)),Stretch_a)) #into dataframe for ggplot
b_df <- as.data.frame(cbind(c(1:length(Stretch_b)),Stretch_b))

colnames(a_df) <- c("x","y") # change column names to match the aes for the plot
colnames(b_df) <- c("x","y")

P_align <- ggplot(NULL, aes(x,y)) + 
  geom_line(data=a_df, colour="red") +
  geom_line(data=b_df, colour="blue")+
  ggtitle("Profil a vs Profil b")
P_align


```

```{r Make_selection}

K1_Z1_A1_ROI1 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 1)
K1_Z2_A1_ROI1 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 2 & Side == "A1" & ROI == 1)

K1_Z1_A2_ROI1 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A2" & ROI == 1)
K1_Z2_A2_ROI1 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 2 & Side == "A2" & ROI == 1)

#Join them up and select y only
Selection1 <- rbind(K1_Z1_A1_ROI1,
                    K1_Z2_A1_ROI1,
                    K1_Z1_A2_ROI1,
                    K1_Z2_A2_ROI1) %>%
  select(y)
  

#Keep names and design a label to be added to ggdendro
labels_Selection1 <- rbind(K1_Z1_A1_ROI1,
                    K1_Z2_A1_ROI1,
                    K1_Z1_A2_ROI1,
                    K1_Z2_A2_ROI1) %>%
  mutate(Label = paste0("Z",Zone,
                        Side,
                        "ROI", ROI,
                        "/",Cut)) %>%
  select(File,Label)

#If we want the labels on all data
labels_ResToolMarks <- ResToolMarks %>%
  mutate(Label = paste0("Z",Zone,
                        Side,
                        "ROI", ROI,
                        "/",Cut)) %>%
  select(File,Label)
```

We can compute DTW distances for all the entities in Selection1. Note that we can process directly lists with proxy::dist().

## With DTW and dtwclust

```{r DTW_distances}
# To compute DTW pairwise distances
mv_distmat_dtwclust <- proxy::dist(Selection1$y,
                                   method = "dtw_basic")

# Transform this list into a matrix to plot a color map

ma_mv_distmat <- as.matrix(mv_distmat_dtwclust)
df_mv_distmat <- as.data.frame(ma_mv_distmat)

# Heatmap from dtw scores, only lower part to avoid repetitive data

get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)}
    
lower_tri <- get_lower_tri(ma_mv_distmat)

m_ma_mv <- melt(lower_tri, na.rm=TRUE) #met toutes les valeurs dans une colonne

ggplot(data = m_ma_mv, aes(x=Var1, y=Var2, fill=value)) + # easy way
  geom_tile()

ggplot(data = m_ma_mv, aes(Var1, Var2, fill = value))+  # fancier way
    geom_tile(color = "white", size=0.1)+
    scale_fill_gradient2(low = "red", high = "yellow", mid = "orange", 
    midpoint = 150, limit = c(60,265), space = "Lab",
    name="DTW score") +
    theme_minimal()+
    theme(axis.line = element_line(linetype="blank"))+
    coord_fixed()+ 
    labs(title= "DTW Scores Intra vs Inter", 
         x= "K1Z1A1       K1Z2A1       K1Z1A2       KZ2A2  ",
         y= "K1Z1A1      K1Z2A1      K1Z1A2      KZ2A2")+
    theme(axis.title.x = element_text(vjust = 1),
          axis.title.y = element_text(vjust = 1))


#To construct a hierarchical clustering
#Distance can be either "dtw" or "dtw_basic" (quicker)
clust.hier <- tsclust(Selection1$y, 
                      type = "hierarchical", 
                      distance = "dtw_basic", 
                      clustering="pam")

#To plot
plot(clust.hier)
```

## DTW with TSclust

Based in the example from https://damien-datasci-blog.netlify.app/post/time-series-clustering-with-dynamic-time-warp/

It gives very similar results compared to tsclust()

```{r TSclust}
#Compute parwise distances
dist_ts <- TSclust::diss(SERIES = Selection1$y, METHOD = "DTWARP")

hc <- stats::hclust(dist_ts, method="complete")
# method can be also "average" or diana (for DIvisive ANAlysis Clustering)
# k for cluster which is 4 in our case 
hclus <- stats::cutree(hc, k = 4) %>% 
  # hclus <- cluster::pam(dist_ts, k = 4)$clustering 
  #has a similar result
  as.data.frame(.) %>%
  dplyr::rename(.,cluster_group = .) %>%
  tibble::rownames_to_column("type_col")

hcdata <- ggdendro::dendro_data(hc)

# Use the following to remove labels from dendogram so not doubling up - but good for checking hcdata$labels$label <- ""

p1 <- hcdata %>%
  ggdendro::ggdendrogram(., rotate=FALSE, leaf_labels=TRUE)

p1
```

It is possible to register a new DTW function adapted to take advantage of specific parameters of the dtw(): step.pattern, open.end, open.begin, etc.

```{r newDTW}
# we specify the new DTW distance as a function
ndtw <- function(x, y, ...) {
  dtw(x, y, ...,
      step.pattern = asymmetric,
      open.end = TRUE,
      open.begin = TRUE,
      distance.only = TRUE)$normalizedDistance
}

#delete name from proxy pr_DB
pr_DB$delete_entry("ndtw")

# Register the distance with proxy
proxy::pr_DB$set_entry(FUN = ndtw, 
                       names = c("nDTW"),
                       loop = TRUE, 
                       type = "metric",
                       distance = TRUE,
                       description = "Normalized, asymmetric DTW")
```

```{r Proxy_Apply_to_selection1}
# Clustering
# It will take some time to compute
cluster.nDTW <- dtwclust::tsclust(Selection1$y,
                      type = "hierarchical",
                      distance = "nDTW")

#Distances
Distance.matrix <- cluster.nDTW@distmat
ma_distmat1 <- as.matrix(Distance.matrix)
df_distmat1 <- as.data.frame(Distance.matrix)
    
lw_distmat1 <- get_lower_tri(ma_distmat1)

m_lw_distmat1 <- melt(lw_distmat1, na.rm=TRUE)

ggplot(data = m_lw_distmat1, aes(Var1, Var2, fill = value))+  # fancier way
    geom_tile(color = "white")+
    scale_fill_gradient2(low = "red", high = "yellow", mid = "orange", 
    limit = c(0.019,0.115), space = "Lab",
    name="DTW score") +
    theme_minimal()+
    theme(axis.line = element_line(linetype="blank"))+
    coord_fixed()+ 
    labs(title= "DTW Scores Intra vs Inter", 
         x= "K1Z1A1       K1Z2A1       K1Z1A2       KZ2A2  ",
         y= "K1Z1A1      K1Z2A1      K1Z1A2      KZ2A2")+
    theme(axis.title.x = element_text(vjust = 1),
          axis.title.y = element_text(vjust = 1))
#Should be the same as but it is not if we display it as a matrix
# This one symetrical when the first one is not


Distance.matrix2 <- proxy::dist(Selection1$y,
                                   method = "nDTW")
ma_distmat2 <- as.matrix(Distance.matrix2)
lw_distmat2 <- get_lower_tri(ma_distmat2)
m_lw_distmat2 <- melt(lw_distmat2, na.rm=TRUE)

ggplot(data = m_lw_distmat2, aes(Var1, Var2, fill = value))+  # fancier way
    geom_tile(color = "white")+
    scale_fill_gradient2(low = "red", high = "yellow", mid = "orange", 
    limit = c(0.019,0.115), space = "Lab",
    name="DTW score") +
    theme_minimal()+
    theme(axis.line = element_line(linetype="blank"))+
    coord_fixed()+ 
    labs(title= "DTW Scores Intra vs Inter", 
         x= "K1Z1A1       K1Z2A1       K1Z1A2       KZ2A2  ",
         y= "K1Z1A1      K1Z2A1      K1Z1A2      KZ2A2")+
    theme(axis.title.x = element_text(vjust = 1),
          axis.title.y = element_text(vjust = 1))

#adapt labels - check manually please
cluster.nDTW$labels <- labels_Selection1$Label
#To plot
plot(cluster.nDTW)

#Plot with ggdendro()
ggdendro::ggdendrogram(as.dendrogram(cluster.nDTW) %>%
                         set("labels_cex", 1),
                       rotate=TRUE, labels=TRUE)

#We can get the distances
#Comment, no differences with Distance.matrix2 ?
distmat_dtwclust_nDTW <- proxy::dist(Selection1$y,
                                   method = "nDTW")

```

Test on a selection2 with the three ROIs.

```{r Selection2}
K1_Z1_A1_ROI1 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 1)
K1_Z1_A1_ROI2 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 2)
K1_Z1_A1_ROI3 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 3)


#Join them up and select y only
Selection2 <- rbind(K1_Z1_A1_ROI1,
                    K1_Z1_A1_ROI2,
                    K1_Z1_A1_ROI3) %>%
  select(File,y)

#Keep names and design a label to be added to ggdendro
labels_Selection2 <- rbind(K1_Z1_A1_ROI1,
                    K1_Z1_A1_ROI2,
                    K1_Z1_A1_ROI3) %>%
  mutate(Label = paste0("Z",Zone,
                        Side,
                        "ROI", ROI,
                        "/",Cut)) %>%
  select(File,Label)

# Clustering
# It will take some time to compute
cluster.nDTW.selection2 <- dtwclust::tsclust(Selection2$y,
                      type = "hierarchical",
                      distance = "nDTW")

#adapt labels - check manually please
cluster.nDTW.selection2$labels <- labels_Selection2$Label
#To plot
plot(cluster.nDTW.selection3)

#Plot with ggdendro()
ggdendro::ggdendrogram(as.dendrogram(cluster.nDTW.selection2) %>%
                         set("labels_cex", 1),
                       rotate=TRUE, labels=TRUE)

```


```{r Selection4}
# Here the objective is to compare regions of interest between them and then reassemble
# To get the 3 scores from a comparison between 2 toolmarks 
# One selection for each ROI to compare ROI's between themselves
Selection4 <- K1_Z1_A1_ROI1 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 1) %>% select(File,y)

Selection5 <- K1_Z1_A1_ROI2 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 2) %>% select(File,y)

Selection6 <- K1_Z1_A1_ROI3 <- ResToolMarks %>%
  filter(Tool == "K1" & Zone == 1 & Side == "A1" & ROI == 3) %>% select(File,y)

# Calculating the distance matrix for each ROI
mv_distmat_dtwclust4 <- proxy::dist(Selection4$y,
                                   method = "nDTW")

mv_distmat_dtwclust5 <- proxy::dist(Selection5$y,
                                   method = "nDTW")

mv_distmat_dtwclust6 <- proxy::dist(Selection6$y,
                                   method = "nDTW")

#creating a dataframe with one column with all the scores for each ROI
DF_S4 <-  cbind(mv_distmat_dtwclust4) %>% as.data.frame()
DF_S5 <-  cbind(mv_distmat_dtwclust5) %>% as.data.frame()
DF_S6 <-  cbind(mv_distmat_dtwclust6) %>% as.data.frame()

# Dataframe with 3 columns, one for each ROI, each row corresponds to a  1v1 toolmark comparison
# Each row has 3 scores, one for each ROI between two toolmarks
DF_K1Z1A1 <-cbind(DF_S4, DF_S5, DF_S6)


# Shorter version for nDTW
DF_S7_nDTW <- proxy::dist(Selection4$y,
                    method = "nDTW") %>% 
         cbind() %>%
         as.data.frame() 
         
DF_S8_nDTW <- proxy::dist(Selection5$y,
                    method = "nDTW") %>% 
         cbind() %>%
         as.data.frame() 
  
DF_S9_nDTW <- proxy::dist(Selection6$y,
                    method = "nDTW") %>% 
         cbind() %>%
         as.data.frame() 

 

DF_K1Z1A1_nDTW <-cbind(DF_S7_nDTW, DF_S8_nDTW, DF_S9_nDTW)
colnames(DF_K1Z1A1_nDTW) <- c("ROI1", "ROI2", "ROI3") #renaming columns 
#adding a column with the average of the 3 values
DF_K1Z1A1_nDTW$Mean <- rowMeans(DF_K1Z1A1_nDTW[,grep("RO",names(DF_K1Z1A1_nDTW))])

#Normalising the score to a value between 0 and 1, a tolerance value has to be chosen
TolScore <- 0.09
DF_K1Z1A1_nDTW$Nscore <- (TolScore-DF_K1Z1A1_nDTW[,4])/TolScore #into a new column


# Same for DTW

DF_S7_DTW <- proxy::dist(Selection4$y,
                    method = "DTW") %>% 
         cbind() %>%
         as.data.frame() 
         
DF_S8_DTW <- proxy::dist(Selection5$y,
                    method = "DTW") %>% 
         cbind() %>%
         as.data.frame() 
  
DF_S9_DTW <- proxy::dist(Selection6$y,
                    method = "DTW") %>% 
         cbind() %>%
         as.data.frame()

DF_K1Z1A1_DTW <-cbind(DF_S7_DTW, DF_S8_DTW, DF_S9_DTW)
colnames(DF_K1Z1A1_DTW) <- c("ROI1", "ROI2", "ROI3") #renaming columns 
#adding a column with the average of the 3 values
DF_K1Z1A1_DTW$Mean <- rowMeans(DF_K1Z1A1_DTW[,grep("RO",names(DF_K1Z1A1_DTW))])

#Normalising the score to a value between 0 and 1, a tolerance value has to be chosen
TolScore <- 130
DF_K1Z1A1_DTW$score <- (TolScore-DF_K1Z1A1_DTW[,4])/TolScore #into a new column

DFmerge <-inner_join(DF_K1Z1A1_DTW,DF_K1Z1A1_nDTW, by = c("ROI1", "ROI2", "ROI3")) 
```

We apply on the all datasets
```{r Proxy_Apply_to_alldata}
# It will take some time to compute
clusterResToolMarks.nDTW <- dtwclust::tsclust(ResToolMarks$y,
                      type = "hierarchical",
                      distance = "nDTW",
                      seed = 1234,
                      trace = TRUE)

clusterResToolMarks.nDTW$labels <- labels_ResToolMarks$Label

#To plot
p2 <- ggdendro::ggdendrogram(as.dendrogram(clusterResToolMarks.nDTW) %>%
                         set("labels_cex", 1),
                       rotate=TRUE, labels=TRUE)
p2

ggsave("dendro1.pdf",p2,width=30,height=100,units="cm")
```




























